<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ez-Dash: Click-to-Move Arena</title>
  <style>
    :root {
      --bg: #0b0f14;        /* near-black blue */
      --panel: #0f1720;
      --ink: #e6f0ff;
      --ink-dim: #b6c3d9;
      --accent: #5dd6ff;    /* cyan */
      --good: #5dffa5;      /* green */
      --warn: #ffd166;      /* amber */
      --bad:  #ff5d7f;      /* pink/red */
      --muted: #7a8aa6;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 50% 50%, #0d131b 10%, var(--bg) 70%);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }
    #wrap {
      display: grid;
      place-items: center;
      height: 100%;
      width: 100%;
    }
    #stage {
      position: relative;
      width: min(96vw, 1280px);
      aspect-ratio: 16 / 9;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      border-radius: 16px;
      overflow: hidden;
      background: #0a0e13;
    }
    canvas#game {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      background: radial-gradient(1000px 700px at 50% 50%, #0a1118 0%, #05080c 70%);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(10,14,19,0.85), rgba(5,8,12,0.92));
      color: var(--ink);
      z-index: 10;
      user-select: none;
    }
    .hidden { display: none; }

    .panel {
      background: rgba(18,24,32,0.75);
      border: 1px solid rgba(255,255,255,0.06);
      padding: 20px 24px;
      border-radius: 14px;
      backdrop-filter: blur(10px) brightness(1.05);
      max-width: 840px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    h1.title {
      margin: 0 0 8px;
      font-size: clamp(22px, 3.6vw, 40px);
      letter-spacing: 0.5px;
    }
    p.sub { margin: 6px 0 16px; color: var(--ink-dim); }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .controls {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 14px;
      color: var(--ink-dim);
    }
    .kbd { padding: 2px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); color: var(--ink); }
    .btn {
      background: linear-gradient(180deg, #18202b, #111821);
      color: var(--ink);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .2px;
    }
    .btn:hover { filter: brightness(1.08); }
    .diff { gap: 6px; }
    .diff .btn[data-d="easy"] { border-color: rgba(93,255,165,.6); }
    .diff .btn[data-d="normal"] { border-color: rgba(93,214,255,.6); }
    .diff .btn[data-d="hard"] { border-color: rgba(255,93,127,.6); }

    .small { font-size: 12px; color: var(--muted); }
    label { color: var(--ink-dim); }
    input[type="text"] {
      background: #0f1620;
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 8px;
      width: 160px;
    }
    .meta { margin-top: 10px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="stage">
      <canvas id="game" width="1280" height="720"></canvas>

      <!-- Start Overlay -->
      <div id="start" class="overlay">
        <div class="panel">
          <h1 class="title">Ez‑Dash: Click‑to‑Move Arena</h1>
          <p class="sub">Right‑click (or <span class="kbd">Shift</span>+<span class="kbd">Left‑Click</span>) to move. 
            Press <span class="kbd">Q</span> to fire at the cursor. Press <span class="kbd">E</span> to dash toward the cursor with brief i‑frames. 
            Dodge enemies and stray projectiles. One hit = game over.</p>
          <div class="row" style="margin:8px 0 6px">
            <div class="row diff">
              <button class="btn" data-d="easy">1 • Easy</button>
              <button class="btn" data-d="normal">2 • Normal</button>
              <button class="btn" data-d="hard">3 • Hard</button>
            </div>
            <div style="flex:1"></div>
            <label>Seed (optional): </label>
            <input id="seedInput" type="text" placeholder="random" />
          </div>
          <div class="controls">
            <div>• Move: Right‑Click / Shift+Left‑Click</div>
            <div>• Shoot: Q (250 ms cd)</div>
            <div>• Dash: E (1.0 s cd, 150 ms i‑frames)</div>
            <div>• Pause / Mute / Restart: P / M / R</div>
          </div>
          <div class="row" style="margin-top:14px">
            <button id="startBtn" class="btn">Start (Space)</button>
            <div class="small">Best score persists locally • 60 FPS target • Deterministic spawns with seed</div>
          </div>
        </div>
      </div>

      <!-- Game Over Overlay -->
      <div id="gameover" class="overlay hidden">
        <div class="panel" id="gameoverPanel">
          <!-- Filled by JS -->
        </div>
      </div>

    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Prevent context menu so right-click can be used for move
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // --- Utility / RNG ------------------------------------------------------
    const qs = new URLSearchParams(location.search);
    const urlSeed = qs.get('seed');

    function hashStringToSeed(str) {
      let h = 2166136261 >>> 0; // FNV-1a
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), 1 | t);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    let rngSeed = urlSeed ? (isNaN(+urlSeed) ? hashStringToSeed(urlSeed) : (+urlSeed >>> 0)) : (Math.random() * 2**32) >>> 0;
    let R = mulberry32(rngSeed);

    const rand = (min=0, max=1) => min + (max - min) * R();
    const randInt = (min, max) => Math.floor(rand(min, max+1));
    const randChoice = (arr) => arr[Math.floor(R() * arr.length)];

    // --- Difficulty ---------------------------------------------------------
    const DIFFS = {
      easy:   { name:'Easy',   enemySpeed: 140, enemySpawn: 1.20, hazardRate: 0.70, hazardSpeed:[120,200], dashCD: 1.00, bounces: 2 },
      normal: { name:'Normal', enemySpeed: 180, enemySpawn: 0.90, hazardRate: 1.20, hazardSpeed:[160,260], dashCD: 1.00, bounces: 3 },
      hard:   { name:'Hard',   enemySpeed: 220, enemySpawn: 0.60, hazardRate: 1.80, hazardSpeed:[200,320], dashCD: 1.20, bounces: 4 },
    };
    let difficultyKey = 'normal';
    let D = DIFFS[difficultyKey];

    // --- Audio --------------------------------------------------------------
    let audioCtx = null;
    let muted = false;
    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function beep({freq=440, dur=0.06, type='sine', vol=0.08}={}) {
      if (muted) return;
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(vol, t0 + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(audioCtx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }
    const sfx = {
      shoot: () => beep({freq: 980, dur: 0.05, type: 'triangle', vol: 0.07}),
      hit:   () => beep({freq: 620, dur: 0.06, type: 'sawtooth', vol: 0.08}),
      death: () => beep({freq: 200, dur: 0.20, type: 'sine', vol: 0.10}),
    };

    // --- Game State ---------------------------------------------------------
    const W = canvas.width, H = canvas.height;
    const CENTER = {x: W/2, y: H/2};

    const STATE = { MENU: 0, PLAY: 1, PAUSE: 2, GAMEOVER: 3 };
    let state = STATE.MENU;

    const keys = new Set();
    let mouse = { x: W/2, y: H/2, inside: false };

    // Player
    const player = {
      x: W/2, y: H/2, r: 16,
      speed: 320,
      target: null, // {x,y}
      shootCD: 0.25,
      dashCD: D.dashCD,
      shootTimer: 0,
      dashTimer: 0,
      iFrames: 0,
      dead: false,
    };

    // Entities
    const projectiles = []; // player bullets
    const enemies = [];
    const hazards = []; // ambient projectiles
    const particles = [];

    let score = 0;
    const BEST_KEY = 'ezdash_best_v1';
    let best = Number(localStorage.getItem(BEST_KEY) || 0);

    // Spawners
    let enemySpawnT = D.enemySpawn; // countdown
    let hazardAccum = 0; // continuous rate per second

    // Flash on lethal
    let deathFlash = 0; // seconds remaining

    // --- Canvas Helpers -----------------------------------------------------
    function clear() {
      ctx.clearRect(0, 0, W, H);
      // subtle vignette grid background draw
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = '#0c141d';
      ctx.lineWidth = 1;
      const grid = 64;
      for (let x = (W%grid); x <= W; x += grid) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = (H%grid); y <= H; y += grid) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();
    }
    function drawCircle(x,y,r, color, alpha=1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle = color; ctx.fill();
      ctx.restore();
    }
    function drawRing(x,y,r, w, color, alpha=1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.lineWidth = w; ctx.strokeStyle = color; ctx.stroke();
      ctx.restore();
    }
    function line(x1,y1,x2,y2,color,alpha=1, width=2) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineWidth = width; ctx.strokeStyle = color; ctx.stroke();
      ctx.restore();
    }

    // --- Math Helpers -------------------------------------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    function len(x,y){ return Math.hypot(x,y); }
    function norm(x,y){ const L=len(x,y)||1; return {x:x/L, y:y/L}; }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    // --- Input --------------------------------------------------------------
    canvas.addEventListener('pointermove', e => {
      const rect = canvas.getBoundingClientRect();
      const rx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const ry = (e.clientY - rect.top) * (canvas.height / rect.height);
      mouse.x = rx; mouse.y = ry; mouse.inside = true;
    });
    canvas.addEventListener('pointerleave', () => mouse.inside = false);

    function setMoveTarget(x, y) { player.target = {x, y}; }

    canvas.addEventListener('pointerdown', e => {
      // Right-click move; fallback Shift+Left-Click
      if (e.button === 2 || (e.button === 0 && (e.shiftKey || keys.has('Shift')))) {
        const rect = canvas.getBoundingClientRect();
        const rx = (e.clientX - rect.left) * (canvas.width / rect.width);
        const ry = (e.clientY - rect.top) * (canvas.height / rect.height);
        setMoveTarget(rx, ry);
      }
    });

    document.addEventListener('keydown', e => {
      keys.add(e.key);
      if (state === STATE.MENU && (e.key === ' ' || e.key === 'Enter')) {
        startGame();
      }
      if (e.key === '1' || e.key === '2' || e.key === '3') {
        setDifficulty(e.key);
      }
      if (state === STATE.PLAY) {
        if (e.key.toLowerCase() === 'q') attemptShoot();
        if (e.key.toLowerCase() === 'e') attemptDash();
      }
      if (e.key.toLowerCase() === 'p') togglePause();
      if (e.key.toLowerCase() === 'm') toggleMute();
      if (e.key.toLowerCase() === 'r') restart();
    });
    document.addEventListener('keyup', e => keys.delete(e.key));

    // Buttons on overlay
    const startOverlay = document.getElementById('start');
    const startBtn = document.getElementById('startBtn');
    const seedInput = document.getElementById('seedInput');
    startBtn.addEventListener('click', startGame);
    document.querySelectorAll('#start .diff .btn').forEach(b => b.addEventListener('click', () => setDifficulty(b.dataset.d)));

    function setDifficulty(code) {
      if (code === '1' || code === 'easy') difficultyKey = 'easy';
      else if (code === '3' || code === 'hard') difficultyKey = 'hard';
      else difficultyKey = 'normal';
      D = DIFFS[difficultyKey];
      player.dashCD = D.dashCD;
      // update visual selection
      document.querySelectorAll('#start .diff .btn').forEach(b => b.style.outline = (b.dataset.d===difficultyKey? '2px solid var(--accent)':'none'));
    }

    function reseedFromUI() {
      const s = seedInput.value.trim();
      if (!s) return; // keep existing seed if blank
      rngSeed = isNaN(+s) ? hashStringToSeed(s) : (+s >>> 0);
      R = mulberry32(rngSeed);
    }

    // --- Core Gameplay ------------------------------------------------------
    function resetRound() {
      player.x = W/2; player.y = H/2; player.target = null; player.shootTimer = 0; player.dashTimer = 0; player.iFrames = 0; player.dead = false;
      enemies.length = 0; hazards.length = 0; projectiles.length = 0; particles.length = 0;
      score = 0; enemySpawnT = D.enemySpawn; hazardAccum = 0; deathFlash = 0;
    }

    function startGame() {
      // Seed precedence: URL ?seed=... > Start overlay input > random
      if (!urlSeed) reseedFromUI();
      resetRound();
      state = STATE.PLAY;
      startOverlay.classList.add('hidden');
      ensureAudio();
    }

    function gameOver() {
      if (state === STATE.GAMEOVER) return;
      state = STATE.GAMEOVER;
      sfx.death();
      best = Math.max(best, score);
      localStorage.setItem(BEST_KEY, String(best));
      showGameOverOverlay();
    }

    function restart() {
      if (state === STATE.MENU) return; // nothing to do
      if (state === STATE.GAMEOVER || state === STATE.PAUSE || state === STATE.PLAY) {
        resetRound();
        state = STATE.PLAY;
        document.getElementById('gameover').classList.add('hidden');
      }
    }

    function togglePause() {
      if (state === STATE.PLAY) { state = STATE.PAUSE; showPauseOverlay(); }
      else if (state === STATE.PAUSE) { state = STATE.PLAY; hideOverlays(); }
    }
    function toggleMute() { muted = !muted; }

    function attemptShoot() {
      if (player.shootTimer > 0) return;
      const dx = mouse.x - player.x, dy = mouse.y - player.y;
      const L = len(dx,dy); if (L < 1) return;
      const v = { x: (dx/L) * 900, y: (dy/L) * 900 };
      projectiles.push({ x: player.x, y: player.y, r: 6, vx: v.x, vy: v.y, life: 1.2 });
      player.shootTimer = player.shootCD;
      sfx.shoot();
    }

    function attemptDash() {
      if (player.dashTimer > 0) return;
      const dir = norm(mouse.x - player.x, mouse.y - player.y);
      const dashDist = 160;
      // Trail particles
      for (let i=0;i<12;i++) {
        const t = i/12;
        particles.push({ x: player.x - dir.x* (t*dashDist), y: player.y - dir.y* (t*dashDist), r: 3+rand(0,2), life: 0.25+rand(0,0.15), color: 'rgba(93,214,255,1)' });
      }
      // Move instantly, clamp within arena
      player.x = clamp(player.x + dir.x * dashDist, player.r, W - player.r);
      player.y = clamp(player.y + dir.y * dashDist, player.r, H - player.r);
      player.iFrames = 0.15; // 150 ms
      player.dashTimer = player.dashCD;
    }

    // --- Spawning -----------------------------------------------------------
    function spawnEnemy() {
      // Random edge position
      const edge = randChoice(['top','bottom','left','right']);
      let x,y;
      if (edge==='top') { x=rand(0,W); y=-20; }
      else if (edge==='bottom') { x=rand(0,W); y=H+20; }
      else if (edge==='left') { x=-20; y=rand(0,H); }
      else { x=W+20; y=rand(0,H); }
      const speed = D.enemySpeed * (0.95 + 0.1*R());
      enemies.push({ x, y, r: 14, speed });
    }

    function spawnHazard(dt) {
      // Poisson with rate D.hazardRate per second
      hazardAccum += D.hazardRate * dt;
      while (hazardAccum >= 1) {
        hazardAccum -= 1;
        const edge = randChoice(['top','bottom','left','right']);
        let x,y, vx,vy;
        if (edge==='top') { x=rand(0,W); y=-10; vx=rand(-1,1); vy=rand(0.2,1); }
        else if (edge==='bottom') { x=rand(0,W); y=H+10; vx=rand(-1,1); vy=-rand(0.2,1); }
        else if (edge==='left') { x=-10; y=rand(0,H); vx=rand(0.2,1); vy=rand(-1,1); }
        else { x=W+10; y=rand(0,H); vx=-rand(0.2,1); vy=rand(-1,1); }
        const sp = rand(D.hazardSpeed[0], D.hazardSpeed[1]);
        const n = norm(vx,vy);
        hazards.push({ x, y, r: 7, vx: n.x*sp, vy: n.y*sp, bounces: D.bounces, life: 10 });
      }
    }

    // --- Update Loop --------------------------------------------------------
    const FIXED_DT = 1/60;
    let last = performance.now();
    let acc = 0;

    function step(dt) {
      if (state !== STATE.PLAY) return; // simulation halts when paused/menu/go

      // Timers
      player.shootTimer = Math.max(0, player.shootTimer - dt);
      player.dashTimer  = Math.max(0, player.dashTimer - dt);
      player.iFrames    = Math.max(0, player.iFrames - dt);
      if (deathFlash > 0) deathFlash = Math.max(0, deathFlash - dt);

      // Movement toward target
      if (player.target) {
        const dx = player.target.x - player.x, dy = player.target.y - player.y;
        const L = len(dx,dy);
        if (L > 2) { const d = {x:dx/L, y:dy/L}; player.x += d.x * player.speed * dt; player.y += d.y * player.speed * dt; }
        if (L < 6) player.target = null;
        // clamp
        player.x = clamp(player.x, player.r, W - player.r);
        player.y = clamp(player.y, player.r, H - player.r);
      }

      // Spawning
      enemySpawnT -= dt; if (enemySpawnT <= 0) { spawnEnemy(); enemySpawnT += D.enemySpawn * (0.9 + 0.2*R()); }
      spawnHazard(dt);

      // Enemies seek player
      for (const e of enemies) {
        const d = norm(player.x - e.x, player.y - e.y);
        e.x += d.x * e.speed * dt;
        e.y += d.y * e.speed * dt;
      }

      // Hazards move + bounce
      for (const h of hazards) {
        h.x += h.vx * dt; h.y += h.vy * dt; h.life -= dt;
        if (h.x < h.r && h.vx < 0) { h.x = h.r; h.vx *= -1; h.bounces--; }
        if (h.x > W - h.r && h.vx > 0) { h.x = W - h.r; h.vx *= -1; h.bounces--; }
        if (h.y < h.r && h.vy < 0) { h.y = h.r; h.vy *= -1; h.bounces--; }
        if (h.y > H - h.r && h.vy > 0) { h.y = H - h.r; h.vy *= -1; h.bounces--; }
      }

      // Bullets move
      for (const b of projectiles) { b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt; }

      // Collisions: bullets vs enemies (stop on first hit)
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const b = projectiles[i];
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r) {
            enemies.splice(j,1); hit = true; score++;
            sfx.hit();
            // particles
            for (let k=0;k<12;k++) {
              const ang = rand(0, Math.PI*2);
              const sp = rand(60, 160);
              particles.push({ x:e.x, y:e.y, r: 2+rand(0,1.5), vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, life: 0.35+rand(0,0.25), color: 'rgba(93,255,165,1)' });
            }
            break;
          }
        }
        if (hit) { projectiles.splice(i,1); continue; }
        if (b.life <= 0 || b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) {
          projectiles.splice(i,1);
        }
      }

      // Collisions: player lethal vs enemies/hazards
      if (player.iFrames <= 0) {
        for (const e of enemies) {
          if (Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r) { deathFlash = 0.25; return gameOver(); }
        }
        for (const h of hazards) {
          if (Math.hypot(player.x - h.x, player.y - h.y) < player.r + h.r) { deathFlash = 0.25; return gameOver(); }
        }
      }

      // Cleanup hazards & enemies offscreen or exhausted
      for (let i = hazards.length-1; i >= 0; i--) {
        const h = hazards[i];
        if (h.life <= 0 || h.bounces < 0 || h.x < -30 || h.x > W+30 || h.y < -30 || h.y > H+30) hazards.splice(i,1);
      }
      for (let i = enemies.length-1; i >= 0; i--) {
        const e = enemies[i];
        if (e.x < -60 || e.x > W+60 || e.y < -60 || e.y > H+60) enemies.splice(i,1);
      }

      // Particles
      for (let i = particles.length-1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt; if (p.vx || p.vy) { p.x += (p.vx||0)*dt; p.y += (p.vy||0)*dt; }
        if (p.life <= 0) particles.splice(i,1);
      }
    }

    function render() {
      clear();

      // Hazards
      for (const h of hazards) {
        drawCircle(h.x, h.y, h.r, 'rgba(255,209,102,0.9)');
      }

      // Enemies
      for (const e of enemies) {
        drawCircle(e.x, e.y, e.r, 'rgba(255,93,127,0.9)');
        drawRing(e.x, e.y, e.r+4, 2, 'rgba(255,93,127,0.35)');
      }

      // Player aim line if shoot is ready
      if (state === STATE.PLAY && player.shootTimer <= 0) {
        const a = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        const lx = player.x + Math.cos(a) * (player.r+4);
        const ly = player.y + Math.sin(a) * (player.r+4);
        line(lx, ly, mouse.x, mouse.y, 'rgba(93,214,255,0.35)', 1, 2);
      }

      // Player
      const iAlpha = player.iFrames > 0 ? 0.8 : 0.25;
      drawRing(player.x, player.y, player.r+6, 3, `rgba(93,214,255,${iAlpha})`);
      drawCircle(player.x, player.y, player.r, 'rgba(93,214,255,0.95)');

      // Bullets
      for (const b of projectiles) {
        drawCircle(b.x, b.y, b.r, 'rgba(200,235,255,0.95)');
      }

      // Particles
      for (const p of particles) {
        const alpha = clamp(p.life / 0.4, 0, 1);
        drawCircle(p.x, p.y, p.r, p.color || 'rgba(93,214,255,1)', alpha);
      }

      // HUD
      drawHUD();

      // Death flash overlay
      if (deathFlash > 0) {
        ctx.save(); ctx.globalAlpha = clamp(deathFlash / 0.25, 0, 1); ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H); ctx.restore();
      }
    }

    function drawHUD() {
      ctx.save();
      ctx.font = '16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif';
      ctx.textBaseline = 'top';

      // Top-left: Score / Best / Difficulty
      const leftPad = 16; let ty = 12;
      ctx.fillStyle = 'rgba(230,240,255,0.92)';
      ctx.fillText(`Score: ${score}`, leftPad, ty); ty += 20;
      ctx.fillStyle = 'rgba(182,195,217,0.92)';
      ctx.fillText(`Best:  ${best}`, leftPad, ty); ty += 20;
      ctx.fillStyle = 'rgba(125,170,200,0.92)';
      ctx.fillText(`Difficulty: ${DIFFS[difficultyKey].name}`, leftPad, ty);

      // Top-right: Cooldowns
      const barW = 160, barH = 12, gap = 8; const right = W - 16;
      function cdBar(label, t, tMax, y, colorReady, colorWait) {
        const x = right - barW;
        const ready = clamp(1 - (t / tMax), 0, 1);
        ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(x, y, barW, barH);
        ctx.fillStyle = t<=0 ? colorReady : colorWait; ctx.fillRect(x, y, barW*ready, barH);
        ctx.fillStyle = 'rgba(182,195,217,0.92)'; ctx.textAlign = 'right'; ctx.fillText(`${label}`, x - 8, y - 2);
        ctx.textAlign = 'left';
      }
      ty = 12;
      cdBar('Q', player.shootTimer, player.shootCD, ty, 'rgba(93,255,165,0.9)', 'rgba(93,214,255,0.75)'); ty += barH + gap;
      cdBar('E', player.dashTimer,  player.dashCD,  ty, 'rgba(93,255,165,0.9)', 'rgba(255,93,127,0.8)');

      // Bottom legend
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(122,138,166,0.9)';
      ctx.fillText('Right‑Click or Shift+Left‑Click = Move  •  Q = Shoot  •  E = Dash  •  P = Pause  •  M = Mute  •  R = Restart  •  1/2/3 = Difficulty', W/2, H - 26);

      ctx.restore();

      // Overlays (pause/gameover) are DOM; start menu is DOM
    }

    // --- Overlays (DOM) ----------------------------------------------------
    function hideOverlays() {
      document.getElementById('gameover').classList.add('hidden');
    }
    function showPauseOverlay() {
      const wrap = document.getElementById('gameover');
      const panel = document.getElementById('gameoverPanel');
      panel.innerHTML = `
        <h2 style="margin:0 0 8px">Paused</h2>
        <div style="color:var(--ink-dim); margin-bottom:10px">Press <span class="kbd">P</span> to resume. <span class="kbd">R</span> to restart.</div>
        <div class="small">Tip: Dashing grants ~150 ms of invulnerability.</div>
      `;
      wrap.classList.remove('hidden');
    }
    function showGameOverOverlay() {
      const wrap = document.getElementById('gameover');
      const panel = document.getElementById('gameoverPanel');
      panel.innerHTML = `
        <h2 style="margin:0 0 6px">Game Over</h2>
        <div style="margin:6px 0 10px">Score: <b>${score}</b>  •  Best: <b>${best}</b>  •  Difficulty: <b>${DIFFS[difficultyKey].name}</b></div>
        <div style="color:var(--ink-dim); margin-bottom:12px">Press <span class="kbd">R</span> to restart, <span class="kbd">P</span> to pause, or <span class="kbd">1/2/3</span> to switch difficulty.</div>
        <div class="small">Hint: Hold Shift to left‑click move if your browser blocks right‑click.</div>
      `;
      wrap.classList.remove('hidden');
    }

    // --- Main Loop ---------------------------------------------------------
    function frame(t) {
      let dt = (t - last) / 1000; last = t; dt = Math.min(dt, 0.1); acc += dt;
      while (acc >= FIXED_DT) { step(FIXED_DT); acc -= FIXED_DT; }
      render();
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // --- URL seed reflects visually on start panel -------------------------
    if (urlSeed) document.getElementById('seedInput').placeholder = urlSeed;

    // --- Expose mouse click to shoot/dash (optional) -----------------------
    // For convenience, left-click (no shift) can shoot when playing; middle-click dash
    canvas.addEventListener('pointerdown', e => {
      if (state !== STATE.PLAY) return;
      if (e.button === 0 && !e.shiftKey) attemptShoot();
      if (e.button === 1) attemptDash();
    });

    // Focus canvas to capture keys more reliably
    window.addEventListener('click', () => canvas.focus && canvas.focus());
  })();
  </script>
</body>
</html>
